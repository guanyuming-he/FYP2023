/**
 * @author Guanyuming He
 */
package edu.guanyfyp.format;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.guanyfyp.generated.JavaLexer;
import edu.guanyfyp.generated.JavaParser.AnnotationContext;
import edu.guanyfyp.syntax.SyntaxContext;

/**
 * A code block represents the format influence of a code token generated by a parser.
 * Here the type of the token will also be taken into consideration because
 * different code blocks fit into different format restrictions.
 */
public class CodeBlock extends FormatToken 
{

	/**
	 * When additional attributes are not available
	 * @param characters
	 * @param position
	 * @param act_pos
	 * @param line
	 * @param index_in_line
	 */
	public CodeBlock
	(
		String characters, 
		int position, int act_pos, 
		int line, int index_in_line
	) 
	{
		super
		(
			characters, position, act_pos, line, index_in_line
		);	
		this.additional_attr = new AdditionalAttributes();
	}
	
	/**
	 * When additional attributes are available
	 * @param characters
	 * @param position
	 * @param act_pos
	 * @param line
	 * @param index_in_line
	 */
	public CodeBlock
	(
		String characters, 
		int position, int act_pos, 
		int line, int index_in_line,
		AdditionalAttributes additional_attributes
	) 
	{
		super
		(
			characters, position, act_pos, line, index_in_line
		);	
		this.additional_attr = additional_attributes;
	}

	@Override
	protected float calculate_format_score(SyntaxContext ctx)
	{
		throw new RuntimeException("Not implemented.");		
	}
	
////////////////////Syntax and Semantics Related ///////////////////////////////
	public enum Type
	{
		// Unknown for now.
		// Perhaps unassigned.
		UNKNOWN,
		
		// Keywords
		// TODO: Perhaps divide keywords
		// into groups of finer granularity
		// that can reflect OOP and other programming styles.
		KEYWORD_UNCLASSIFIED,
		
		// Literals
		STRING_LITERAL,
		NUMBER_LITERAL,
		BOOL_LITERAL,
		NULL_LITERAL,
		
		// Punctuation
		SEMICOLON,
		COMMA,
		DOT,
		// Parentheses
		L_PARENTHESIS,
		R_PARENTHESIS,
		// square brackets
		L_SBRACKET,
		R_SBRACKET,
		// curly brackets
		L_CBRACKET,
		R_CBRACKET,
		
		// Identifiers
		// IDENTIFIER_UNCLASSIFIED is a token that is known to be an identifier at the lexer level,
		// but remains to be classified by the parser
		IDENTIFIER_UNCLASSIFIED,
		CLASS_NAME,
		INTERFACE_NAME,
		ENUM_NAME,
		CONSTRUCTOR_NAME,
		METHOD_NAME,
		// variable of some class
		FIELD_NAME,
		// variable of other things
		VARIABLE_NAME,
		// parameter of some method
		PARAMETER_NAME,
		
		// Operators
		OPERATOR_UNCLASSIFIED,
		
		// Others
		OTHERS,
	}
	
	/**
	 * Additional attributes that are only known after syntax or semantic analysis
	 */
	public static final class AdditionalAttributes
	{
		public AdditionalAttributes()
		{
			this.type = Type.UNKNOWN;
			this.OOP_modifiers = 0;
			this.other_modifiers = 0;
			this.annotationModifiers = new ArrayList<>();
		}
		/**
		 * (deep) copy constructor
		 * @param other who will be deep-copied
		 */
		public AdditionalAttributes(AdditionalAttributes other)
		{
			this.type = other.type;
			this.OOP_modifiers = other.OOP_modifiers;
			this.other_modifiers = other.other_modifiers;
			this.annotationModifiers = new ArrayList<AnnotationContext>(other.annotationModifiers);
		}
		
		/**
		 * Construct directly from the field variables.
		 * @param type
		 * @param OOP_modifiers
		 * @param other_modifiers
		 * @param annotation_modifiers will be deep-copied
		 */
		public AdditionalAttributes
		(
			CodeBlock.Type type,
			int OOP_modifiers,
			int other_modifiers,
			List<AnnotationContext> annotation_modifiers
		)
		{
			this.type = type;
			this.OOP_modifiers = OOP_modifiers;
			this.other_modifiers = other_modifiers;
			this.annotationModifiers = new ArrayList<AnnotationContext>(annotation_modifiers);
		}
		
		/**
		 * Deep-copies other to this.
		 * @param other
		 */
		public void assign(AdditionalAttributes other)
		{
			this.type = other.type;
			this.OOP_modifiers = other.OOP_modifiers;
			this.other_modifiers = other.other_modifiers;
			this.annotationModifiers = new ArrayList<AnnotationContext>(other.annotationModifiers);
		}
		
		/**
		 * shallow-copies other to this.
		 * @param other
		 */
		public void move(AdditionalAttributes other)
		{
			this.type = other.type;
			this.OOP_modifiers = other.OOP_modifiers;
			this.other_modifiers = other.other_modifiers;
			this.annotationModifiers = other.annotationModifiers;
		}
		
		// The type of the code token.
		// Not final because the information may not be available at creation.
		private CodeBlock.Type type;
		
		/*
		 * In java, modifiers are generally divided into two classes:
		 * Keyword modifiers and annotation modifiers.
		 * The following two are keyword modifiers
		 */
		
		// modifiers related to OOP
		private int OOP_modifiers;
		// other modifiers
		private int other_modifiers;
		
		// This is the list of annotation modifiers
		private List<AnnotationContext> annotationModifiers;
		public void addAnnotationModifier(AnnotationContext annotation)
		{
			annotationModifiers.add(annotation);
		}
		
		/**
		 * modifiers related to access and inheritance
		 * stored using bitwise operations
		 */
		// Access modifiers
		public static final int OOP_MODIFIER_PUBLIC = 0x1;
		public static final int OOP_MODIFIER_PROTECTED = 0x2;
		public static final int OOP_MODIFIER_PRIVATE = 0x4;
		public static final int OOP_MODIFIER_DEFAULT = 0x8;
		// Inheritance modifiers
		public static final int OOP_MODIFIER_ABSTRACT = 0x10;
		/**
		 * modifiers that do not intersect with the above
		 * stored using bitwise operations
		 */
		public static final int MODIFIER_FINAL = 0x1;
		public static final int MODIFIER_STATIC = 0x2;
		public static final int MODIFIER_STRICTFP = 0x4;
		public static final int MODIFIER_NATIVE = 0x8;
		public static final int MODIFIER_SYNCHRONIZED = 0x10;
		public static final int MODIFIER_TRANSIENT = 0x20;
		public static final int MODIFIER_VOLATILE = 0x40;
		
		// type methods
		public Type getType() { return type; }
		public void setType(Type type) { this.type = type; }
		/**
		* Assigns this CodeBlock a type based on what the lexer can tell me about it.
		* @param tokenType
		*/
		public void setTypeFromLexerTokenType(int tokenType)
		{
			switch(tokenType)
			{
			// Keywords
			case JavaLexer.ABSTRACT:
			case JavaLexer.ASSERT:
			case JavaLexer.BOOLEAN:
			case JavaLexer.BREAK:
			case JavaLexer.BYTE:
			case JavaLexer.CASE:
			case JavaLexer.CATCH:
			case JavaLexer.CHAR:	
			case JavaLexer.CLASS:
			case JavaLexer.CONST:
			case JavaLexer.CONTINUE:
			case JavaLexer.DEFAULT:	
			case JavaLexer.DO:
			case JavaLexer.DOUBLE:
			case JavaLexer.ELSE:
			case JavaLexer.ENUM:	
			case JavaLexer.EXTENDS:
			case JavaLexer.FINAL:
			case JavaLexer.FINALLY:
			case JavaLexer.FLOAT:
			case JavaLexer.FOR:
			case JavaLexer.IF:
			case JavaLexer.GOTO:
			case JavaLexer.IMPLEMENTS:	
			case JavaLexer.IMPORT:
			case JavaLexer.INSTANCEOF:
			case JavaLexer.INT:
			case JavaLexer.INTERFACE:	
			case JavaLexer.LONG:
			case JavaLexer.NATIVE:
			case JavaLexer.NEW:
			case JavaLexer.PACKAGE:	
			case JavaLexer.PRIVATE:
			case JavaLexer.PROTECTED:
			case JavaLexer.PUBLIC:
			case JavaLexer.RETURN:
			case JavaLexer.SHORT:
			case JavaLexer.STATIC:
			case JavaLexer.STRICTFP:
			case JavaLexer.SUPER:	
			case JavaLexer.SWITCH:
			case JavaLexer.SYNCHRONIZED:
			case JavaLexer.THIS:
			case JavaLexer.THROW:	
			case JavaLexer.THROWS:
			case JavaLexer.TRANSIENT:
			case JavaLexer.TRY:
			case JavaLexer.VOID:	
			case JavaLexer.VOLATILE:
			case JavaLexer.WHILE:
			// Module-related keywords
			case JavaLexer.MODULE:
			case JavaLexer.OPEN:
			case JavaLexer.REQUIRES:
			case JavaLexer.EXPORTS:
			case JavaLexer.OPENS:
			case JavaLexer.TO:	
			case JavaLexer.USES:
			case JavaLexer.PROVIDES:
			case JavaLexer.WITH:
			case JavaLexer.TRANSITIVE:	
			// var
			case JavaLexer.VAR:
			// switch expressions (Java17)
			case JavaLexer.YIELD:
			// records
			case JavaLexer.RECORD:
			// Sealed classes
			case JavaLexer.SEALED:	
			case JavaLexer.PERMITS:
			case JavaLexer.NON_SEALED:
				this.type = Type.KEYWORD_UNCLASSIFIED;
				break;
			
			// Literals
			case JavaLexer.DECIMAL_LITERAL:
			case JavaLexer.HEX_LITERAL:
			case JavaLexer.OCT_LITERAL:
			case JavaLexer.BINARY_LITERAL:
			case JavaLexer.FLOAT_LITERAL:
			case JavaLexer.HEX_FLOAT_LITERAL:
				this.type = Type.NUMBER_LITERAL;
				break;
			case JavaLexer.CHAR_LITERAL:
			case JavaLexer.STRING_LITERAL:
			case JavaLexer.TEXT_BLOCK:
				this.type = Type.STRING_LITERAL;
				break;
			case JavaLexer.BOOL_LITERAL:
				this.type = Type.BOOL_LITERAL;
				break;
			case JavaLexer.NULL_LITERAL:
				this.type = Type.NULL_LITERAL;
				break;
			
			// Punctuation
			case JavaLexer.SEMI:
				this.type = Type.SEMICOLON;
				break;
			case JavaLexer.COMMA:
				this.type = Type.COMMA;
				break;
			case JavaLexer.DOT:
				this.type = Type.DOT;
				break;
			case JavaLexer.LPAREN:
				this.type = Type.L_PARENTHESIS;
				break;
			case JavaLexer.RPAREN:
				this.type = Type.R_PARENTHESIS;
				break;
			case JavaLexer.LBRACE:
				this.type = Type.L_CBRACKET;
				break;
			case JavaLexer.RBRACE:
				this.type = Type.R_CBRACKET;
				break;
			case JavaLexer.LBRACK:
				this.type = Type.L_SBRACKET;
				break;
			case JavaLexer.RBRACK:
				this.type = Type.R_SBRACKET;
				break;
			
			// Operators
			case JavaLexer.ASSIGN:
			// Comparisons
			case JavaLexer.GT:
			case JavaLexer.LT:
			case JavaLexer.EQUAL:	
			case JavaLexer.LE:
			case JavaLexer.GE:
			case JavaLexer.NOTEQUAL:
			// ...
			case JavaLexer.BANG:
			case JavaLexer.TILDE:
			case JavaLexer.QUESTION:
			case JavaLexer.COLON:
			// Logical
			case JavaLexer.AND:	
			case JavaLexer.OR:
			// Math
			case JavaLexer.INC:
			case JavaLexer.DEC:
			case JavaLexer.ADD:	
			case JavaLexer.SUB:
			case JavaLexer.MUL:
			case JavaLexer.DIV:
			case JavaLexer.BITAND:
			case JavaLexer.BITOR:
			case JavaLexer.CARET:
			case JavaLexer.MOD:
			// Op-assign
			case JavaLexer.ADD_ASSIGN:	
			case JavaLexer.SUB_ASSIGN:
			case JavaLexer.MUL_ASSIGN:
			case JavaLexer.DIV_ASSIGN:
			case JavaLexer.AND_ASSIGN:	
			case JavaLexer.OR_ASSIGN:
			case JavaLexer.XOR_ASSIGN:
			case JavaLexer.LSHIFT_ASSIGN:
			case JavaLexer.RSHIFT_ASSIGN:	
			case JavaLexer.URSHIFT_ASSIGN:
			case JavaLexer.MOD_ASSIGN:
				this.type = Type.OPERATOR_UNCLASSIFIED;
				break;
			
			// Identifier
			case JavaLexer.IDENTIFIER:
				this.type = Type.IDENTIFIER_UNCLASSIFIED;
				break;
			
			// Misc
			case JavaLexer.ARROW:	
			case JavaLexer.COLONCOLON:
			case JavaLexer.AT:
			case JavaLexer.ELLIPSIS:
				this.type = Type.OTHERS;
				break;
			
			default:
			// Should never reach here because I should have handled all types
			assert false;
			}
		}
		
		// modifier methods
		public void set_OOP_modifier(int mod)
		{
			OOP_modifiers |= mod;
		}
		public void set_other_modifier(int mod)
		{
			other_modifiers |= mod;
		}
		public void assign_OOP_modifiers(int mod)
		{
			OOP_modifiers = mod;
		}
		public void assign_other_modifiers(int mod)
		{
			other_modifiers = mod;
		}
		public int get_OOP_modifiers()
		{
			return OOP_modifiers;
		}
		public int get_other_modifiers()
		{
			return other_modifiers;
		}
		public boolean has_OOP_modifier(int mod)
		{
			return (OOP_modifiers & mod) != 0;
		}
		public boolean has_other_modifier(int mod)
		{
			return (other_modifiers & mod) != 0;
		}
	}

	public final AdditionalAttributes additional_attr;
}
