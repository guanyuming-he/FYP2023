/**
 * 
 */
package edu.guanyfyp.syntax;

import java.util.HashMap;
import java.util.Locale.IsoCountryCode;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;

import edu.guanyfyp.SourceFile;
import edu.guanyfyp.format.CodeBlock;
import edu.guanyfyp.format.CodeBlock.AdditionalAttributes;
import edu.guanyfyp.format.FormatToken;
import edu.guanyfyp.generated.JavaParser;
import edu.guanyfyp.generated.JavaParserBaseListener;
import edu.guanyfyp.generated.JavaParser.AnnotationContext;
import edu.guanyfyp.generated.JavaParser.ForInitContext;

/**
 * Builds a SyntaxContext by walking the parse tree
 */
public class SyntaxStructureBuilder extends JavaParserBaseListener {

	public SyntaxStructureBuilder(SourceFile sf) 
	{
		this.sourceFile = sf;
		this.additionalTokenAttributes = new HashMap<>();
	}

	
///////////////////////////// Fields and related methods /////////////////////////
	/**
	 * Reference to the SourceFile that produced this listener.
	 * The listener will attach more information to the tokens of the source_file.
	 */
	private final SourceFile sourceFile;
	/**
	 * The syntax structure the listener will build during a walk.
	 * It should be complete after a walk.
	 */
	private final SyntaxStructure syntaxStructure = new SyntaxStructure();
	public SyntaxStructure getSyntaxStructure()
	{
		return syntaxStructure;
	}
	
	
	// A list of additional attributes for the format tokens is built during a walk.
	// token index (in the token stream, getTokenIndex()) -> additional information
	// Because the tokens that the parser processes are only CodeBlocks,
	// only this Type's information is needed.
	private final HashMap<Integer, CodeBlock.AdditionalAttributes> additionalTokenAttributes;
	public HashMap<Integer, CodeBlock.AdditionalAttributes> getAdditionalTokenAttributes()
	{
		return additionalTokenAttributes;
	}
	
	/**
	 * Should only be called after a complete walk on the parsing tree
	 * to apply the obtained additional attributes to the format tokens
	 * in the SourceFile
	 */
	public void applyAdditionalTokenAttributes()
	{
		var indices = additionalTokenAttributes.keySet();
		for(int ind : indices)
		{
			CodeBlock cb = (CodeBlock)sourceFile.getFormatToken(ind);
			// move the additional attributes to the code block's
			cb.additionalAttr.move(additionalTokenAttributes.get(ind));
		}
	}
	
	
	/**
	 * Here, during the syntax and potential semantic analysis,
	 * I will attach additional attributes to each identifier in the source code.
	 * 
	 * However, because of the structure of the Java grammar, the attributes may not
	 * be fully known at one place, but often needs information around the identifier.
	 * Hence, I create this pending attributes variable that waits to be applied to an identifier.
	 * 
	 * The pending attributes will be consumed by the first code block that uses it
	 * and be reset to nothing.
	 * 
	 * On a legal piece of Java code, this reset process should work without problems.
	 */
	private AdditionalAttributes pendingAttributes = new AdditionalAttributes();
	
	/**
	 * Resets pending_modifiers to having no additional information
	 * i.e. to a new AdditionalAttributes();
	 */
	private void resetPendingAttributes() 
	{ 
		pendingAttributes = new AdditionalAttributes();
	}
	
///////////////////////////// Helpers /////////////////////////////////
	/**
	 * Adds the corresponding modifier to the pending additional attributes
	 * based on the given parser rule context, modifier
	 * @param modifier the context generated by the parser
	 */
	private void add_pending_modifier(ParserRuleContext modifier)
	{
		// If it is an annotation modifier.
		if (modifier instanceof AnnotationContext)
		{
			pendingAttributes.addAnnotationModifier((AnnotationContext)modifier);
			return;
		}
		
		// Otherwise, it is a keyword modifier
		switch(modifier.getText())
		{
		// I only care about these keyword modifiers in this project.
		// Other keywords are ignored.
		case "public" -> 
			pendingAttributes.setOopModifier(AdditionalAttributes.OOP_MODIFIER_PUBLIC);
		case "protected" ->
			pendingAttributes.setOopModifier(AdditionalAttributes.OOP_MODIFIER_PROTECTED);
		case "private" ->
			pendingAttributes.setOopModifier(AdditionalAttributes.OOP_MODIFIER_PRIVATE);
		case "static" -> 
			pendingAttributes.setOtherModifiers(AdditionalAttributes.MODIFIER_STATIC);
		case "abstract" ->
			pendingAttributes.setOopModifier(AdditionalAttributes.OOP_MODIFIER_ABSTRACT);
		case "final" ->
			pendingAttributes.setOtherModifiers(AdditionalAttributes.MODIFIER_FINAL);
		case "strictfp" -> 
			pendingAttributes.setOtherModifiers(AdditionalAttributes.MODIFIER_STRICTFP);
		}
	}
	
	/**
	 * Sets the additional modifiers for the corresponding code block
	 * @see The comment for pendingTypeModifiers
	 * 
	 * @param type the type of the CodeBlock (e.g. class, interface, enum)
	 * @param tokenInd the index of the token of the code piece
	 * @param reset whether to reset the pending attributes at the end
	 */
	private void setAdditionalTokenAttributesForTheCode
	(
		CodeBlock.Type type, int tokenInd,
		boolean reset
	)
	{
		// Sets the type of the code block
		pendingAttributes.setType(type);
		// Adds the attributes to the list
		additionalTokenAttributes.put(tokenInd, pendingAttributes);
		// Resets the attributes to a new and blank object, 
		// if the parameter orders so
		if(reset) resetPendingAttributes();
	}
	
	/**
	 * the same as calling setAdditionalTokenAttributesForTheCode(type, tokenInd, true)
	 * @param type
	 * @param tokenInd
	 */
	private void setAdditionalTokenAttributesForTheCode(CodeBlock.Type type, int tokenInd)
	{
		setAdditionalTokenAttributesForTheCode(type, tokenInd, true);
	}
	
	
///////////////////////////// Inherited parser methods /////////////////////////////////
	/**
	 * Because I care about the modifiers, I have to explore here
	 * @see the comment for pending_type_modifiers
	 */
	@Override
	public void enterTypeDeclaration(JavaParser.TypeDeclarationContext ctx)
	{		
		var modifiersList = ctx.classOrInterfaceModifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
	}
	
	/**
	 * ClassBodyDeclarations also include modifiers
	 * @see the comment for pending_type_modifiers
	 */
	@Override
	public void enterClassBodyDeclaration(JavaParser.ClassBodyDeclarationContext ctx)
	{	
		var modifiersList = ctx.modifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
	}
	
	/**
	 * InterfaceBodyDeclarations also include modifiers
	 * @see the comment for pending_type_modifiers
	 */
	@Override
	public void enterInterfaceBodyDeclaration(JavaParser.InterfaceBodyDeclarationContext ctx)
	{
		var modifiersList = ctx.modifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
	}
	
	/**
	 * LocalTypeDeclarationDeclarations also include modifiers
	 * @see the comment for pending_type_modifiers
	 */
	@Override
	public void enterLocalTypeDeclaration(JavaParser.LocalTypeDeclarationContext ctx)
	{
		var modifiersList = ctx.classOrInterfaceModifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
	}
	
	/**
	 * All method parameters go here
	 * I can handle both the modifiers and the identifiers here
	 * @see the comment for pending_type_modifiers
	 */
	@Override
	public void enterFormalParameters(JavaParser.FormalParametersContext ctx)
	{
		//  receiverParameter?
        //| receiverParameter (COMMA formalParameterList)?
        //| formalParameterList?
		
		// need to handle both the receiver parameter
		// and the formal parameters
		// But I can handle them independently
		
		// first check the receive parameters
		var rp = ctx.receiverParameter();
		if(rp != null)
		{
			// receive parameters do not have modifiers
			var identifiers = rp.identifier();
			for(var par : identifiers)
			{
				Token token = par.getStart();
				setAdditionalTokenAttributesForTheCode(CodeBlock.Type.PARAMETER_NAME, token.getTokenIndex());
			}
		}
		
		// then check the formal parameters
		var fp_list = ctx.formalParameterList();
		if(fp_list != null)
		{
			var formal_parameters = fp_list.formalParameter();
			if(formal_parameters != null)
			{
				for(var fp : formal_parameters)
				{
					var modifiers = fp.variableModifier();
					for(var modifier : modifiers)
					{
						add_pending_modifier(modifier);
					}
					
					Token token = fp.variableDeclaratorId().identifier().getStart();
					setAdditionalTokenAttributesForTheCode(CodeBlock.Type.PARAMETER_NAME, token.getTokenIndex());
				}
			}
			
			// But it can also be lastFormalParameter
			var lfp = fp_list.lastFormalParameter();
			if(lfp != null)
			{
				var modifiers = lfp.variableModifier();
				for(var modifier : modifiers)
				{
					add_pending_modifier(modifier);
				}
				
				Token token = lfp.variableDeclaratorId().identifier().getStart();
				setAdditionalTokenAttributesForTheCode(CodeBlock.Type.PARAMETER_NAME, token.getTokenIndex());
			}
		}
	}
	
	/**
	 * LocalVariableDeclarations include modifiers, too.
	 * But it also has only one possibility of declarations
	 * (unlike type declaration, where I could have a class, interface, enum, or annotation)
	 * Therefore, I can handle the type at the same time here.
	 * @see the comment for pending_type_modifiers
	 */
	@Override
	public void enterLocalVariableDeclaration(JavaParser.LocalVariableDeclarationContext ctx)
	{
		var modifiersList = ctx.variableModifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
		
		// decide if it is a local variable or a for-loop variable
		CodeBlock.Type local_or_for;
		if(ctx.getParent() instanceof ForInitContext)
		{
			local_or_for = CodeBlock.Type.FOR_VARIABLE_NAME;
		}
		else
		{
			local_or_for = CodeBlock.Type.VARIABLE_NAME;
		}
		
		// variableModifier* (VAR identifier ASSIGN expression | typeType variableDeclarators)
		// See if this is a var declaration or explicit declaration
		if(ctx.identifier() != null)
		{
			// This is a var declaration
			
			// The local variable name token
			Token token = ctx.identifier().getStart();
			setAdditionalTokenAttributesForTheCode(local_or_for, token.getTokenIndex());
		}
		else
		{
			// this is declared using variableDeclarators
			var variable_declarator_list = ctx.variableDeclarators().variableDeclarator();
			for(var variable_declarator : variable_declarator_list)
			{
				// One variable token.
				Token token = variable_declarator.variableDeclaratorId().identifier().getStart();
				
				// don't reset
				setAdditionalTokenAttributesForTheCode(local_or_for, token.getTokenIndex(), false);
			}
			// don't forget to reset pending_modifiers in the end
			resetPendingAttributes();
		}
	}

	/**
	 * When a declaration of a class is encountered
	 */
	@Override
	public void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx)
	{
		// the class name token.
		Token token = ctx.identifier().getStart();
		
		// additional attributes
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.CLASS_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of an enumeration is encountered
	 */
	@Override
	public void enterEnumDeclaration(JavaParser.EnumDeclarationContext ctx)
	{
		// the enumeration name token.
		Token token = ctx.identifier().getStart();

		// additional attributes
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.ENUM_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of an interface is encountered
	 */
	@Override
	 public void enterInterfaceDeclaration(JavaParser.InterfaceDeclarationContext ctx)
	 {
		// the interface name token.
		Token token = ctx.identifier().getStart();

		// additional attributes
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.INTERFACE_NAME, token.getTokenIndex());
	 }
	
	/**
	 * When a declaration of a class method is encountered
	 */
	@Override
	public void enterMethodDeclaration(JavaParser.MethodDeclarationContext ctx)
	{
		// the method name token.
		Token token = ctx.identifier().getStart();
	
		// additional attributes
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.METHOD_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of a generic class method is encountered
	 */
	@Override
	public void enterGenericMethodDeclaration(JavaParser.GenericMethodDeclarationContext ctx)
	{
		// the generic method name token.
		Token token = ctx.methodDeclaration().identifier().getStart();
	
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.METHOD_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of an interface method is encountered
	 */
	@Override
	public void enterInterfaceMethodDeclaration(JavaParser.InterfaceMethodDeclarationContext ctx)
	{
		// Strangely, there can be some additional modifiers here
		var modifiersList = ctx.interfaceMethodModifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
		
		// the method name token.
		Token token = ctx.interfaceCommonBodyDeclaration().identifier().getStart();
	
		// additional attributes
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.METHOD_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of a generic interface method is encountered
	 */
	@Override
	public void enterGenericInterfaceMethodDeclaration(JavaParser.GenericInterfaceMethodDeclarationContext ctx)
	{
		// Strangely, there can be some additional modifiers here
		var modifiersList = ctx.interfaceMethodModifier();
		for(var modifier : modifiersList)
		{
			add_pending_modifier(modifier);
		}
		
		// the generic method name token.
		Token token = ctx.interfaceCommonBodyDeclaration().identifier().getStart();
	
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.METHOD_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of a constructor is encountered
	 */
	@Override
	public void enterConstructorDeclaration(JavaParser.ConstructorDeclarationContext ctx)
	{
		// the constructor name token.
		Token token = ctx.identifier().getStart();
	
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.CONSTRUCTOR_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of a generic constructor is encountered
	 */
	@Override
	public void enterGenericConstructorDeclaration(JavaParser.GenericConstructorDeclarationContext ctx)
	{
		// the generic constructor method name token.
		Token token = ctx.constructorDeclaration().identifier().getStart();
	
		setAdditionalTokenAttributesForTheCode(CodeBlock.Type.CONSTRUCTOR_NAME, token.getTokenIndex());
	}
	
	/**
	 * When a declaration of a field is encountered
	 */
	@Override 
	public void enterFieldDeclaration(JavaParser.FieldDeclarationContext ctx)
	{
		// A field declaration can declare multiple variables,
		// as in "int a, b, c;"
		var variable_declarator_list = ctx.variableDeclarators().variableDeclarator();
		for(var variable_declarator : variable_declarator_list)
		{
			// One variable token.
			Token token = variable_declarator.variableDeclaratorId().identifier().getStart();
			
			// Don't reset
			setAdditionalTokenAttributesForTheCode(CodeBlock.Type.FIELD_NAME, token.getTokenIndex(), false);
		}
		// don't forget to reset pending_modifiers in the end
		resetPendingAttributes();
	}
}
